set nocompatible                                             " Treure la compatibilitat amb Vi

filetype off
filetype plugin indent on
filetype plugin on

call plug#begin('~/.vim/plugged')

  Plug 'chrisbra/Colorizer'             " Mostra el color dels codis i noms de color del text
  Plug 'junegunn/fzf.vim'               " Permet utilitzar fzf dins de vim
  Plug 'yuki-ycino/fzf-preview.vim'     " Ús de FZF a una finestra flotant de neovim
  Plug 'gorkunov/smartpairs.vim'        " Seleccions incrementals utilitzant v consecutivament
  Plug 'gillyb/stable-windows'          " Manté estable la finestra quan hi ha canvis de layout (help, fzf...)
  Plug 'keith/swift.vim'                " Permet ressaltar colors i indentar fitxers Swift
  Plug 'mbbill/undotree'                " Mostra l'arbre de modificacions d'un fitxer
  Plug 'vim-airline/vim-airline'        " Barra d'estat i de buffers/tabs
  Plug 'vim-airline/vim-airline-themes' " Barra d'estat i de buffers/tabs
  Plug 'tpope/vim-commentary'           " Gestionar comentaris fàcilment
  Plug 'Lokaltog/vim-easymotion'        " Per saltar entre paraules, cerques, etc. de manera més àgil
  Plug 'int3/vim-extradite'             " Amplia funcionalitat de fugitive mostrant commits
  Plug 'tpope/vim-fugitive'             " Utilitzar Git dins de Vim
  Plug 'szw/vim-g'                      " Obre una pestanya al navegador amb el text a buscar (DuckDuckGo)
  Plug 'machakann/vim-highlightedyank'  " Destaca en vermell el text copiat al portapapers
  Plug 'adelarsq/vim-matchit'           " Extén els tipus de coincidències de la comanda %
  Plug 'xolox/vim-misc'                 " Recull d'scripts. Necessari per vim-session
  Plug 'pbrisbin/vim-mkdir'             " Crea els directoris necessaris en guardar un fitxer
  Plug 'tpope/vim-repeat'               " Permet utilitzar '.' per repetir comandes de surround.vim, speeddating.vim, unimpaired.vim, vim-easyclip i vim-radical
  Plug 'xolox/vim-session'              " Amplia la gestió de sessions de vim (necessita miv-misc
  Plug 'lifepillar/vim-solarized8'      " Esquema de colors Solarized
  Plug 'tpope/vim-surround'             " mitjançant l'acció 's' es posen i treuen parentesis, claudators, cometes simples, un tag...
  Plug 'christoomey/vim-tmux-navigator' " Navegar fluidament entre tmux i vim
  Plug 'tpope/vim-unimpaired'           " Utilitzant [ i ] es poden realitzar moviments o canvis de text o canvis de comportaments
  Plug 'ryanoasis/vim-devicons'         " Posa icones a vim-airline
  Plug 'bfredl/nvim-miniyank'           " Guarda els textos copiats a un fitxer comú compartit per totes les instàncies de vim
  Plug 'matze/vim-move'                 " Permet moure línies senceres (actual o seleccionades) amunt o avall amb Alt j o k
  Plug 'junegunn/vim-easy-align'        " Alinea parts de línies al mateix nivell segons el caràcter indicat
  Plug 'psliwka/vim-smoothie'           " Desplaçaments verticals del buffer amb moviment, per seguir-ho fàciment
  Plug 'mhinz/vim-startify'             " Substitueix la pantalla d'entrada de vim per algo més útil amb ultims fitxers oberts

call plug#end()

filetype on

""""""""""""""""""""""""""""""""""""""""""""""""""
" Funcions
"""""""""""""""""""""""""""""""""""""""""""""""""""
function! EnsureDirExists (dir)
" Funció per crear directoris si no existeixen
    if !isdirectory(a:dir)
        if exists('*mkdir')
            call mkdir(a:dir,'p')
        endif
    endif
endfunc

function! DeleteTrailingWS()
" Funció per esborrar els espais a final de línia del buffer
    let previous_search=@/
    let previous_cursor_line=line('.')
    let previous_cursor_column=col('.')
    %s/\s\+$//ge
    let @/=previous_search
    call cursor(previous_cursor_line, previous_cursor_column)
endfunc

function! RetabIndents()
" Funció que canvia espais per tabs al principi de línia del buffer
    let previous_search=@/
    let previous_cursor_line=line('.')
    let previous_cursor_column=col('.')
    if &expandtab
        execute '%s@^\(\t\)\+@\=repeat(repeat(" ", '.&ts.'), len(submatch(0)))@e'
    else
        execute '%s@^\(\ \{'.&ts.'\}\)\+@\=repeat("\t", len(submatch(0))/'.&ts.')@e'
    endif
    let @/=previous_search
    call cursor(previous_cursor_line, previous_cursor_column)
endfunc

" Use Q to intelligently close a window
" (if there are multiple windows into the same buffer)
" or kill the buffer entirely if it's the last window looking into that buffer
function! CloseWindowOrKillBuffer()
    let number_of_windows_to_this_buffer = len(filter(range(1, winnr('$')), "winbufnr(v:val) == bufnr('%')"))

    " We should never bdelete a nerd tree
    if matchstr(expand("%"), 'NERD') == 'NERD'
        wincmd c
        return
    endif

    if number_of_windows_to_this_buffer > 1
        wincmd c
    else
        bdelete
    endif
endfunction

command! -nargs=0 -bar Qargs execute 'args' QuickfixFilenames()
function! QuickfixFilenames()
  " Building a hash ensures we get each buffer only once
  let buffer_numbers = {}
  for quickfix_item in getqflist()
    let buffer_numbers[quickfix_item['bufnr']] = bufname(quickfix_item['bufnr'])
  endfor
  return join(map(values(buffer_numbers), 'fnameescape(v:val)'))
endfunction


""""""""""""""""""""""""""""""""""""""""""""""""""
" Creació de directoris
""""""""""""""""""""""""""""""""""""""""""""""""""
" :silent call EnsureDirExists($HOME.'/.vim_backup')           " Crear directori de backup
" :silent call EnsureDirExists($HOME.'/.vim_swap')             " Crear directori de swap
:silent call EnsureDirExists($HOME.'/.vim_undo')             " Crear directori de undo
:silent call EnsureDirExists($HOME.'/.vim_view')             " Crear directori de view
:silent call EnsureDirExists($HOME.'/.vim_sessions')         " Crear directori de sessions


""""""""""""""""""""""""""""""""""""""""""""""""""
" General
""""""""""""""""""""""""""""""""""""""""""""""""""

" Mantenir la posició del cursor quan obres un buffer al mateix lloc a on el tenies al tancar-lo
autocmd BufWinLeave *.* silent! mkview
autocmd BufWinEnter *.* silent! loadview
autocmd FocusLost *.* silent! :wa

" When restoring a hidden buffer Vim doesn't always keep the same view (like
" when your view shows beyond the end of the file). (Vim tip 1375)
if ! &diff
    au BufLeave * let b:winview = winsaveview()
    au BufEnter * if(exists('b:winview')) | call winrestview(b:winview) | endif
endif

" Posar al títol de la finestra el path del buffer que estem editant
let &titlestring = expand('%:pwd')
if &term == 'screen' || &term == 'xterm'
    set title
endif

" keyboard shortcuts
let mapleader = " "

let loaded_netrw = 0

set autoindent                                               " Activar autoindendació
set autoread                                                 " Reload files when changed on disk, i.e. via `git checkout`
set backspace=2                                              " Fix broken backspace in some setups
" set backupdir=~/.vim_backup                                  " Canviar directori de buffer de backup
if has('mac')
    set clipboard=unnamed                                    " Yank and paste with the system clipboard
elseif has('unix')
    set clipboard=unnamedplus                                " Yank and paste with the system clipboard
endif
set cursorline                                               " Ressalta la línia a on està el cursor
set encoding=UTF-8                                           " Posar UTF-8 com a encoding per defecte
set expandtab tabstop=4 softtabstop=4 shiftwidth=4           " Definir els tabs com 4 espais
set foldlevel=99
set foldmethod=manual                                        " Es creen folds directament amb la indentació
set foldnestmax=1                                            " Perquè es crein folds només al primer nivell d'indentació
set hidden                                                   " Permet moure entre buffers encara que aquests estiguin editats sense guardar
set history=10000                                            " Guarda les 10000 últimes comandes
set hlsearch                                                 " Es ressalten les coincidencies de la cerca
set ignorecase                                               " Case-sensitive search if any caps
set incsearch                                                " Search as you type
set infercase                                                " Per fer case sensitive l'autocomplete
set iskeyword+=_,@                                           " Not word dividers
set laststatus=2                                             " Always show statusline
set lazyredraw                                               " No repinta la pantalla mentre s'executen macros, més ràpid
set linebreak
set nolist                                                   " No ressaltar els caràcters especials
set listchars=tab:▸\ ,trail:▫,eol:↵,extends:»,precedes:«     " Llistat de caràcters especials que es ressalten
set mouse=                                                   " Deshabilitar el ratolí
set noerrorbells                                             " No vull errors sonors
set visualbell                                               " No vull errors visuals
set nowrap sidescroll=1 sidescrolloff=1                      " No tallar frases
set noswapfile
set nrformats=                                               " Per utilitzar el sistema decimal, no octal a l'incrementar o decrementar números
set number                                                   " Show line numbers
set relativenumber                                           " Shows relative numbers
set ruler                                                    " Show where you are
set showcmd                                                  " Mostra els parcials de les comandes
set showtabline=2                                            " Mostra la barra de tabs/buffers sempre
set smartcase                                                " Case-sensitive search if any caps
set splitright splitbelow                                    " Obre les noves finestres a la dreta i a sota
set switchbuf=usetab                                         " A l'obrir un nou fitxer posiciona a la tab/finestra que el tingui, no l'obre de nou
set tags=tags                                                " Afegir tags del virtualenv als tags per defecte
set undodir=~/.vim_undo                                      " Canviar directori de fitxers de undo
set undofile                                                 " Undo persistent, encara que es tanqui el buffer
set undolevels=10000                                         " Augmenta a 10000 el nivel de undo
set undoreload=10000                                         " Augmenta a 10000 el nivel de redo
set viewdir=~/.vim_view                                      " Canviar directori de fitxers de view
set wildignore=*/tmp/,*/.git/*,*.so,*.swp,*.zip,*.pdf,*.bak,*.pyc,*.pyo,*.class,*.tmp,*~      " Ignorar aquests tipus de fitxers
set wildmenu                                                 " Show a navigable menu for tab completion on command line
set wildmode=full                                            " Mostra les possibilitats d'una comanda rotllo zsh
if !has('nvim')
  set term=screen-256color
else
  set guifont=DroidSansMono_Nerd_Font:h11
endif
set pastetoggle=<f5>

set path+=**
set suffixesadd+=.php,.py

" TAGS
autocmd BufNewFile,BufRead *.h,*.m set tags+=~/Documents/global-objc-tags

" Activar colors al text
syntax on

set t_Co=256                                                 " Número de colors
set termguicolors
let base16colorspace=256
set background=dark
colorscheme solarized8
highlight SpecialKey ctermbg=NONE guibg=NONE
" Highlights selection in yellow
hi Visual cterm=reverse guifg=#b4881d guibg=#022b35
if !has('gui_running')
    highlight Normal ctermbg=NONE guibg=NONE
endif

" set Vim-specific sequences for RGB colors
let &t_8f = "\<Esc>[38;2;%lu;%lu;%lum"
let &t_8b = "\<Esc>[48;2;%lu;%lu;%lum"


""""""""""""""""""""""""""""""""""""""""""""""""""
" Mapeig de teclat en mode inserció
""""""""""""""""""""""""""""""""""""""""""""""""""

" Anar al mode normal des del mode insert amb jj o jk
inoremap jk <Esc>


""""""""""""""""""""""""""""""""""""""""""""""""""
" Mapeig de teclat en mode comanda
""""""""""""""""""""""""""""""""""""""""""""""""""

" Escriu a la línia de comandes el directori actual posant %%
cnoremap %% <C-R>=fnameescape(expand('%:h')).'/'<Cr>

" Permet moure's per la història de comandes amb <C-n> i <C-p>
cnoremap <C-p> <Up>
cnoremap <C-n> <Down>

cmap w!! w !sudo tee % >/dev/null


""""""""""""""""""""""""""""""""""""""""""""""""""
" Mapeig de comandes
""""""""""""""""""""""""""""""""""""""""""""""""""

" Si escribim malament el guardar i/o sortir de vim, que funcioni
command! WQ wq
command! Wq wq
command! W w
command! Q q

command! Qa qa


""""""""""""""""""""""""""""""""""""""""""""""""""
" Mapeig de teclat en mode normal
""""""""""""""""""""""""""""""""""""""""""""""""""

" Tracta les línies llarques com a línies separades
map j gj
map k gk

" Moure a la finestra dreta amb Ctrl-H
nmap <C-h> <C-w>h
" Moure a la finestra inferior amb Ctrl-J
nmap <C-j> <C-w>j
" Moure a la finestra superior amb Ctrl-K
nmap <C-k> <C-w>k
" Moure a la finestra esquerra amb Ctrl-L
nmap <C-l> <C-w>l

" Utilitzar Ctrl-C per comentar/descomentar línies de codi
map <C-c> gcc<Esc>

map gb :bnext<Cr>
map gB :bprevious<Cr>

" Utilitzar <Tab> en lloc de % per moure pels "aparellats"
nnoremap <Tab> %

" Reload vimrc
nnoremap gsv :so $MYVIMRC<CR>
let g:WebDevIconsUnicodeDecorateFileNodesDefaultSymbol = 'ƛ'

" Per fer redo es pot amb <C-r> i amb U
nnoremap U <C-r>
nnoremap :: @:

" Centra verticalment cada nova ocurrència d'una cerca
nnoremap n nzz
nnoremap N Nzz

" Copiar del caràcter actual al final de línia amb la tecla Y, per similitud amb D i C
nmap Y y$

" Separar línies amb K
nnoremap K i<Cr><Esc>^

" Guardar el buffer actual amb <Leader>w
nnoremap <Leader>w :w<CR>
" Guardar el buffer actual i tancar-lo amb <Leader>W
nnoremap <Leader>W :wq<CR>

" Posar la configuració de tabs a 2 espais amb <Leader><Leader>2
nnoremap <Leader><Leader>2 <Esc>:set noexpandtab tabstop=2 softtabstop=2 shiftwidth=2<Cr>
" Posar la configuració de tabs a 4 espais amb <Leader><Leader>4
nnoremap <Leader><Leader>4 <Esc>:set noexpandtab tabstop=4 softtabstop=4 shiftwidth=4<Cr>
" Posar la configuració de 4 espais amb <leader><leader>0
nnoremap <Leader><Leader>0 <Esc>:set expandtab tabstop=4 softtabstop=4 shiftwidth=4<Cr>

" Utilitzar Q per tancar buffers
nnoremap <silent> Q :call CloseWindowOrKillBuffer()<Cr>

" Per seleccionar l'últim text enganxat
nnoremap <expr> gv '`[' . strpart(getregtype(), 0, 1) . '`]'

" Indica un nom de fitxer pel buffer actual
map <Leader>c :f <C-R>=expand('%:p:h') . '/' <Cr>

map <Leader>n :enew<Cr>i

" Esborra els espais al final de totes les línies amb <Leader>dt
noremap <silent> <Leader>dt :call DeleteTrailingWS()<Cr>
" Canvia els espais per tabuladors al principi de totes les línies amb <Leader>ri
noremap <silent> <Leader>ri :call RetabIndents()<Cr>

" Repeteix la última cerca amb els mateixos flags amb & en mode normal, visual o de selecció
nnoremap & :&&<CR>
xnoremap & :&&<CR>

if has('nvim')
    " Sortir del terminal de neovim amb Esc
  tnoremap <Esc> <C-\><C-n>
endif

augroup CursorLineOnlyInActiveWindow
    autocmd!
    autocmd VimEnter,WinEnter,BufWinEnter * setlocal cursorline
    autocmd WinLeave * setlocal nocursorline
augroup END

if has("eval")
    function! SL(function)
        if exists('*'.a:function)
            return call(a:function,[])
        else
            return ''
        endif
    endfunction
endif


""""""""""""""""""""""""""""""""""""""""""""""""""
" Configuració de plugins
""""""""""""""""""""""""""""""""""""""""""""""""""

" vim-g: Obre finestra al navegador amb el text a buscar
let g:vim_g_query_url = "https://duckduckgo.com/?q="
let g:vim_g_command = "Go"

" undotree
nnoremap <Leader>u :call undotree#UndotreeToggle()<Cr>
let g:undotree_WindowLayout = 2
let g:undotree_ShortIndicators = 1
let g:undotree_SetFocusWhenToggle = 1

" vim-session
let g:session_directory = '~/.vim_sessions'
let g:session_autoload = 'yes'
let g:session_autosave = 'yes'
let g:session_command_aliases = 1
nnoremap <Leader>so :OpenSession
nnoremap <Leader>ss :SaveSession
nnoremap <Leader>sd :DeleteSession<Cr>
nnoremap <Leader>sc :CloseSession<Cr>

" vim-airline: Línia de status i de buffers
let g:airline_section_c = '%f'
let g:airline_section_y = ''
let g:airline#extensions#tagbar#enabled = 0
let g:airline#extensions#hunks#enabled = 0
let g:airline#extensions#virtualenv#enabled = 0
let g:airline_left_sep=''
let g:airline_right_sep=''
let g:airline#extensions#tabline#show_buffers = 1
let g:airline#extensions#tabline#enabled = 1
let g:airline#extensions#tabline#formatter = 'unique_tail_improved'
let g:airline#extensions#tabline#buffer_nr_show = 1
let g:airline#extensions#bufferline#enabled = 1
let g:airline#extensions#whitespace#checks = []
let g:airline_powerline_fonts = 1

" smoothie
let g:smoothie_update_interval = 20
let g:smoothie_base_speed = 25

" vim-easy-align
xmap ga <Plug>(EasyAlign)
nmap ga <Plug>(EasyAlign)

" FZF
let g:fzf_history_dir = $HOME.'/.fzf-history'
" In order to work with vim
set rtp+=/usr/local/opt/fzf

" miniyank
let g:miniyank_filename = $HOME."/.miniyank.mpack"
let g:miniyank_maxitems = 100

function! FZFYankList() abort
  function! KeyValue(key, val)
    let line = join(a:val[0], '')
    if (a:val[1] ==# 'V')
      let line = line
    endif
    return a:key.' '.line
  endfunction
  return map(miniyank#read(), function('KeyValue'))
endfunction

function! FZFYankHandler(opt, line) abort
  let key = substitute(a:line, ' .*', '', '')
  if !empty(a:line)
    let yanks = miniyank#read()[key]
    call miniyank#drop(yanks, a:opt)
  endif
endfunction

command! YanksAfter call fzf#run(fzf#wrap('YanksAfter', {
\ 'source':  FZFYankList(),
\ 'sink':    function('FZFYankHandler', ['p']),
\ 'options': '--no-sort --no-preview --prompt="YanksAfter> "',
\ }))

command! YanksBefore call fzf#run(fzf#wrap('YanksBefore', {
\ 'source':  FZFYankList(),
\ 'sink':    function('FZFYankHandler', ['P']),
\ 'options': '--no-sort --no-preview --prompt="YanksBefore> "',
\ }))

map <leader>ya :YanksAfter<CR>
map <leader>yb :YanksBefore<CR>

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
""""" Versió 1
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

"if has('nvim')
"    hi Floating guibg=#022b35

"    nnoremap <Leader>ff  :<C-u>FzfPreviewDirectoryFiles<CR>
"    nnoremap <Leader>fgs :<C-u>FzfPreviewGitStatus<CR>
"    nnoremap <Leader>fgf :<C-u>FzfPreviewGitFiles<CR>
"    nnoremap <Leader>fb  :<C-u>FzfPreviewBuffers<CR>
"    nnoremap <Leader>fgr :<C-u>FzfPreviewProjectGrep<Space>
"    nnoremap <Leader>ft  :<C-u>FzfPreviewBufferTags<CR>

"else
"    nmap <Leader>f :FZF!<Cr>
"    nmap <Leader>b :Buffers!<Cr>
"    nmap <Leader>. :Tags!<Cr>
"    inoremap <C-f> <Esc><Esc>:BLines!<CR>
"    let $FZF_DEFAULT_COMMAND = 'ag -g ""'
"    "let $FZF_DEFAULT_OPTS .= ' --preview'
"    let g:fzf_preview_window = 'right:60%'

"    function! s:fzf_statusline()
"        highlight fzf1 ctermfg=161 ctermbg=251
"        highlight fzf2 ctermfg=23 ctermbg=251
"        highlight fzf3 ctermfg=237 ctermbg=251
"        setlocal statusline=%#fzf1#\ >\ %#fzf2#fz%#fzf3#f
"    endfunction
"    autocmd! User FzfStatusLine call <SID>fzf_statusline()
"endif




" Files + devicons
let g:max_lines=10000
nnoremap <silent> <leader>i :call Fzf_files_with_dev_icons($FZF_DEFAULT_COMMAND, "Files")<CR>
" GFiles?
nnoremap <silent> <leader>j :call Fzf_git_diff_files_with_dev_icons()<CR>
" Gfiles
nnoremap <silent> <leader>k :call Fzf_files_with_dev_icons("git ls-files \| uniq", "Git files")<CR>

function! Fzf_files_with_dev_icons(command, prompt)
  let l:fzf_files_options = '--preview "bat --color always --style=numbers,changes {2..} | head -' . g:max_lines . '" --reverse'

  function! s:edit_devicon_prepended_file(item)
    let l:file_path = a:item[4:-1]
    execute 'silent e' l:file_path
  endfunction

  let opts = fzf#wrap({})
  let opts['source'] = a:command . ' | devicon-lookup'
  let opts['sink'] = function('s:edit_devicon_prepended_file')
  let opts['options'] = '-m --preview-window=right:60%:border --prompt "' . a:prompt . ' > " ' . l:fzf_files_options
  let opts['down'] = '40%'
  let opts['window'] = {'width': 0.9, 'height': 0.9}

  call fzf#run(opts)
endfunction

function! Fzf_git_diff_files_with_dev_icons()
  let l:fzf_files_options = '--ansi --preview "sh -c \"(git diff --color=always -- {3..}) \""'

  function! s:edit_devicon_prepended_file_diff(item)
    echom a:item
    let l:file_path = a:item[7:-1]
    echom l:file_path
    let l:first_diff_line_number = system("git diff -U0 " . l:file_path . " | rg '^@@.*\+' -o | rg '[0-9]+' -o | head -1")
    execute 'silent e' l:file_path
    execute l:first_diff_line_number
  endfunction

  let opts = fzf#wrap({})
  let opts['source'] = 'git -c color.status=always status --short --untracked-files=all | devicon-lookup'
  let opts['sink'] = function('s:edit_devicon_prepended_file_diff')
  let opts['options'] = '-m --preview-window=right:60%:border --prompt "Untracked files > " ' . l:fzf_files_options
  let opts['down'] = '40%'
  let opts['window'] = {'width': 0.9, 'height': 0.9}

  call fzf#run(opts)
endfunction

nnoremap <silent> <leader>b :call BufWidth()<CR>
function! BufWidth()
  let width = winwidth(0)
  let numberwidth = max([&numberwidth, strlen(line('$'))+1])
  let numwidth = (&number || &relativenumber)? numberwidth : 0
  let foldwidth = &foldcolumn

  if &signcolumn == 'yes'
    let signwidth = 2
  elseif &signcolumn == 'auto'
    let signs = execute(printf('sign place buffer=%d', bufnr('')))
    let signs = split(signs, "\n")
    let signwidth = len(signs)>2? 2: 0
  else
    let signwidth = 0
  endif
  echo width
  return width - numwidth - foldwidth - signwidth
endfunction


" vim-startify
" returns all modified files of the current git repo
" `2>/dev/null` makes the command fail quietly, so that when we are not
" in a git repo, the list will be empty
function! s:gitModified()
    let files = systemlist('git ls-files -m 2>/dev/null')
    return map(files, "{'line': v:val, 'path': v:val}")
endfunction

" same as above, but show untracked files, honouring .gitignore
function! s:gitUntracked()
    let files = systemlist('git ls-files -o --exclude-standard 2>/dev/null')
    return map(files, "{'line': v:val, 'path': v:val}")
endfunction

let g:startify_lists = [
        \ { 'type': 'files',     'header': ['   MRU']            },
        \ { 'type': 'dir',       'header': ['   MRU '. getcwd()] },
        \ { 'type': 'sessions',  'header': ['   Sessions']       },
        \ { 'type': 'bookmarks', 'header': ['   Bookmarks']      },
        \ { 'type': function('s:gitModified'),  'header': ['   git modified']},
        \ { 'type': function('s:gitUntracked'), 'header': ['   git untracked']},
        \ { 'type': 'commands',  'header': ['   Commands']       },
        \ ]


if exists("g:loaded_webdevicons")
    call webdevicons#refresh()
endif
